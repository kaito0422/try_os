红黑树   
   
   
   
对于kernel中的内存管理   

首先采用伙伴算法的思想，把对应大小的内存挂到free_area数组上去，但是我们会发现：在伙伴算法中，一开始是没有对物理内存进行划分的，即一开始是一整块内存，当第一次用户申请 1页 的物理内存时，会对整块内存进行划分，不断地取一半一半，最后划分到 1页 大小的时候，就完成了物理内存的分配；但是当物理内存释放的时候，伙伴算法的做法是把能够合并的物理内存页尽可能的合并。   

这样子的做法只会在下一次较小的物理页链表中不够的时候，再去从较大的物理页链表中分配来进行拆分的操作变得更多，从而增加申请物理内存的时间消耗。   

但是如果我们一开始就设计好每种物理页的大小对应的节点数量，在系统上电的时候就初始化分配好这些的物理页到free_area数组的对应链表中，在物理内存分配和释放的时候不是真的从链表中进行插入删除（其实也可以插入删除，因为如果是双向的循环链表的插入和删除还是比较快的），而是知识做一个标记，表示该内存用过了（或者没用过），这样就省去了划分大页和合并小页的过程，降低时间开销   

（因为在当前移动端和PC端的游戏开发中都会有加载加大地图和3D物体模型，可能会需要动态分配较大的内存来存放这部分数据，但是当场景变化了之后，原先的那部分数据就需要得到释放，这时候就会不断地去分配和释放较大的物理内存）   

因此，如果通过操作系统内核提供的profile工具，对于运行一个（或者一类）应用程序时，不同页面大小分配的次数，就能构建一个页大小所需度的分布情况，该分布式一个二维分布，横坐标是每次分配多少个页，纵坐标是一次就分配这么多页的内存申请的次数，则根据这个分布，我们就能在系统初始化（或者游戏初始化）的时候就构建一个特定的free_area，专门针对这个分布进行不同内存大小的链表构建，比如一次性分配4页的内存申请操作占据80%，则就在free_area[2]（对应于2^2个页）的链表中多初始化几个节点，这样就可以尽量避免内存分配不够的时候，需要去划分大的free_area中的节点   
